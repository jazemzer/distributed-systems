{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome here! I'm not an expert in systems design but I've lately started reading more about designing distributed systems. And this site is an attempt to document my notes both for sharing and future reference. As I begin this journey, though I have a list of topics to cover, I don't have a concrete structure in my mind to organize these notes. But I hope over time I should be able to find a structure and reorganize them. TODO: Enterprise Patterns Java Optimization Java for small teams Networking 101","title":"Welcome here!"},{"location":"index.html#welcome-here","text":"I'm not an expert in systems design but I've lately started reading more about designing distributed systems. And this site is an attempt to document my notes both for sharing and future reference. As I begin this journey, though I have a list of topics to cover, I don't have a concrete structure in my mind to organize these notes. But I hope over time I should be able to find a structure and reorganize them.","title":"Welcome here!"},{"location":"index.html#todo","text":"Enterprise Patterns Java Optimization Java for small teams Networking 101","title":"TODO:"},{"location":"books/mis.html","text":"Make it stick Learning is misunderstood Rereading text and rapid-fire repetition (massed practice) is transitory, least productive and makes no difference in the long run creates an illusion of mastery Recalling facts, concepts or events from memory is more effective strategy Spacing out practice or interleaving recall practice creates long lasting learning Trying to solve the problem before being taught increases learning Research doesn't back up the idea of auditory or visual learner Testing as a tool for learning Without quizzing we overestimate mastery Testing identifies shows unknown unknowns Elaboration - Expressing a concept in one's own words strengthens learning Extracting key ideas, organizing into mental models and connecting to prior knowledge helps in complex mastery Learning is stronger when it matters Mastery = Readily available Knowledge + understanding of how to use it Takeaway Quiz yourselves regularly Elaborate or take notes in your own words Retrieve to learn","title":"Make it stick"},{"location":"books/mis.html#make-it-stick","text":"","title":"Make it stick"},{"location":"books/mis.html#learning-is-misunderstood","text":"Rereading text and rapid-fire repetition (massed practice) is transitory, least productive and makes no difference in the long run creates an illusion of mastery Recalling facts, concepts or events from memory is more effective strategy Spacing out practice or interleaving recall practice creates long lasting learning Trying to solve the problem before being taught increases learning Research doesn't back up the idea of auditory or visual learner Testing as a tool for learning Without quizzing we overestimate mastery Testing identifies shows unknown unknowns Elaboration - Expressing a concept in one's own words strengthens learning Extracting key ideas, organizing into mental models and connecting to prior knowledge helps in complex mastery Learning is stronger when it matters Mastery = Readily available Knowledge + understanding of how to use it","title":"Learning is misunderstood"},{"location":"books/mis.html#takeaway","text":"Quiz yourselves regularly Elaborate or take notes in your own words","title":"Takeaway"},{"location":"books/mis.html#retrieve-to-learn","text":"","title":"Retrieve to learn"},{"location":"books/ddia/building_blocks.html","text":"Designing data-intensive applications What are the 5 standard building blocks Databases to store data Caches to speed-up reads or remember expensive operation Queues/Streams for asynchronous processing Indexes for searching and filtering stored data Offline processing for crunching accumulated data or async operations What are the 3 major concerns in most software systems Reliability - means making systems work correctly, even when faults occur. Can the system gracefully handle hardware/software faults and human errors? This is about being fault-tolerant or resilient. Scalability - means having strategies for keeping performance good, even when load (either in traffic or data volume) increases. Maintainability - is about making life better for engineering and operations teams Define Reliability System's ability to continue to work correctly, even when things go wrong. The things that can go wrong are called faults What is the difference between Fault vs Failure In a complex system, fault is when one of the components deviates from the specification. Whereas, failure is when the system as a whole stops working. What are the different types of faults Hardware faults disk crash, faulty RAM, power blackout, network failure Software Errors Edge cases crashing the process Memory leak Cascading failures Human errors Configuration errors How to handle different types of faults Hardware failures - Add redundancy to individual hardware component Disk - RAID configuration Server - Dual power supplies Hot-swappable CPUs Datacenter with backup power (batteries or diesel generators) Software Errors Testing Process isolation Allow crash and automatic restart Monitoring & Alerting Human Errors Fully featured Sandbox environment Thorough testing - Unit test, Integration test, etc Gradual code rollout Ease to rollback configuration changes Telemetry - Detailed monitoring Good training Define Scalability System's ability to cope up with increase load (traffic/data) How to describe a system's current load? Current load on the system can be described using a number (called load parameter ) as below: web req/sec ratio of db reads and writes Cache hit ratio simultaneous active users How to describe a system's performance ? Before investigating what happens when the load increases, the system's performance can be benchmarked Batch systems Throughput Time take to complete work that uses a dataset of fixed size Online systems latency/response time measured in percentiles What are tail latencies? High percentiles of response time are called tail latencies. They are important because it can represent customers with the most data How to cope with increased load? Design and build systems for estimated future growth Choose wisely between scaling-up and scaling-out Consider elastic systems that scale automatically when the load increases Consider shared-nothing architectures Define Maintainability It can be defined in these 3 design principles Operability - Make it easy for operations teams to run the system smoothly Simplicity - Make it easy for new engineers to understand the system Avoiding big ball of mud Removing accidental complexity with good abstractions Evolvability - Make it easy to make future changes - Extensibility or Plasticity Encoding and Evolution Json cannot distinguish integer and floating-point numbers and there is no precision doesn't support binary strings - sequence of bytes without any encoding Binary encodings of Json - MessagePack, BSON, BJSON, UBJSON, BISON, and Smile, to name a few What is the space saved for ProtoBuf compared to Json Document databases * Doesn't nicely handle one-to-many information because you cannot do joins in db but have to do in application layer * Schema flexibility due to storage locality Network model - one record could have multiple parents - to represent both one-to-many and many-to-many relationships Schema-on-read vs schema-on-write * 1 is advantageous when the schema is changing Locality in Spanner, Oracle (Multi table index cluster tables), Bigtable data model Document reference in MongoDB Mongodb offers MapReduce Triple stores","title":"Building blocks"},{"location":"books/ddia/building_blocks.html#designing-data-intensive-applications","text":"","title":"Designing data-intensive applications"},{"location":"books/ddia/building_blocks.html#what-are-the-5-standard-building-blocks","text":"Databases to store data Caches to speed-up reads or remember expensive operation Queues/Streams for asynchronous processing Indexes for searching and filtering stored data Offline processing for crunching accumulated data or async operations","title":"What are the 5 standard building blocks"},{"location":"books/ddia/building_blocks.html#what-are-the-3-major-concerns-in-most-software-systems","text":"Reliability - means making systems work correctly, even when faults occur. Can the system gracefully handle hardware/software faults and human errors? This is about being fault-tolerant or resilient. Scalability - means having strategies for keeping performance good, even when load (either in traffic or data volume) increases. Maintainability - is about making life better for engineering and operations teams","title":"What are the 3 major concerns in most software systems"},{"location":"books/ddia/building_blocks.html#define-reliability","text":"System's ability to continue to work correctly, even when things go wrong. The things that can go wrong are called faults","title":"Define Reliability"},{"location":"books/ddia/building_blocks.html#what-is-the-difference-between-fault-vs-failure","text":"In a complex system, fault is when one of the components deviates from the specification. Whereas, failure is when the system as a whole stops working.","title":"What is the difference between Fault vs Failure"},{"location":"books/ddia/building_blocks.html#what-are-the-different-types-of-faults","text":"Hardware faults disk crash, faulty RAM, power blackout, network failure Software Errors Edge cases crashing the process Memory leak Cascading failures Human errors Configuration errors","title":"What are the different types of faults"},{"location":"books/ddia/building_blocks.html#how-to-handle-different-types-of-faults","text":"Hardware failures - Add redundancy to individual hardware component Disk - RAID configuration Server - Dual power supplies Hot-swappable CPUs Datacenter with backup power (batteries or diesel generators) Software Errors Testing Process isolation Allow crash and automatic restart Monitoring & Alerting Human Errors Fully featured Sandbox environment Thorough testing - Unit test, Integration test, etc Gradual code rollout Ease to rollback configuration changes Telemetry - Detailed monitoring Good training","title":"How to handle different types of faults"},{"location":"books/ddia/building_blocks.html#define-scalability","text":"System's ability to cope up with increase load (traffic/data)","title":"Define Scalability"},{"location":"books/ddia/building_blocks.html#how-to-describe-a-systems-current-load","text":"Current load on the system can be described using a number (called load parameter ) as below: web req/sec ratio of db reads and writes Cache hit ratio simultaneous active users","title":"How to describe a system's current load?"},{"location":"books/ddia/building_blocks.html#how-to-describe-a-systems-performance","text":"Before investigating what happens when the load increases, the system's performance can be benchmarked Batch systems Throughput Time take to complete work that uses a dataset of fixed size Online systems latency/response time measured in percentiles","title":"How to describe a system's performance ?"},{"location":"books/ddia/building_blocks.html#what-are-tail-latencies","text":"High percentiles of response time are called tail latencies. They are important because it can represent customers with the most data","title":"What are tail latencies?"},{"location":"books/ddia/building_blocks.html#how-to-cope-with-increased-load","text":"Design and build systems for estimated future growth Choose wisely between scaling-up and scaling-out Consider elastic systems that scale automatically when the load increases Consider shared-nothing architectures","title":"How to cope with increased load?"},{"location":"books/ddia/building_blocks.html#define-maintainability","text":"It can be defined in these 3 design principles Operability - Make it easy for operations teams to run the system smoothly Simplicity - Make it easy for new engineers to understand the system Avoiding big ball of mud Removing accidental complexity with good abstractions Evolvability - Make it easy to make future changes - Extensibility or Plasticity","title":"Define Maintainability"},{"location":"books/ddia/building_blocks.html#encoding-and-evolution","text":"Json cannot distinguish integer and floating-point numbers and there is no precision doesn't support binary strings - sequence of bytes without any encoding Binary encodings of Json - MessagePack, BSON, BJSON, UBJSON, BISON, and Smile, to name a few What is the space saved for ProtoBuf compared to Json Document databases * Doesn't nicely handle one-to-many information because you cannot do joins in db but have to do in application layer * Schema flexibility due to storage locality Network model - one record could have multiple parents - to represent both one-to-many and many-to-many relationships Schema-on-read vs schema-on-write * 1 is advantageous when the schema is changing Locality in Spanner, Oracle (Multi table index cluster tables), Bigtable data model Document reference in MongoDB Mongodb offers MapReduce Triple stores","title":"Encoding and Evolution"},{"location":"books/ddia/data_models.html","text":"","title":"Data models"},{"location":"books/ddia/encoding.html","text":"Encoding and Evolution Json cannot distinguish integer and floating-point numbers and there is no precision doesn't support binary strings - sequence of bytes without any encoding Binary encodings of Json - MessagePack, BSON, BJSON, UBJSON, BISON, and Smile, to name a few What is the space saved for ProtoBuf compared to Json Document databases * Doesn't nicely handle one-to-many information because you cannot do joins in db but have to do in application layer * Schema flexibility due to storage locality Network model - one record could have multiple parents - to represent both one-to-many and many-to-many relationships Schema-on-read vs schema-on-write * 1 is advantageous when the schema is changing Locality in Spanner, Oracle (Multi table index cluster tables), Bigtable data model Document reference in MongoDB Mongodb offers MapReduce Triple stores","title":"Encoding"},{"location":"books/ddia/encoding.html#encoding-and-evolution","text":"Json cannot distinguish integer and floating-point numbers and there is no precision doesn't support binary strings - sequence of bytes without any encoding Binary encodings of Json - MessagePack, BSON, BJSON, UBJSON, BISON, and Smile, to name a few What is the space saved for ProtoBuf compared to Json Document databases * Doesn't nicely handle one-to-many information because you cannot do joins in db but have to do in application layer * Schema flexibility due to storage locality Network model - one record could have multiple parents - to represent both one-to-many and many-to-many relationships Schema-on-read vs schema-on-write * 1 is advantageous when the schema is changing Locality in Spanner, Oracle (Multi table index cluster tables), Bigtable data model Document reference in MongoDB Mongodb offers MapReduce Triple stores","title":"Encoding and Evolution"},{"location":"concepts/architecture.html","text":"Web Architecture 101 HTTP Push Ajax Long polling Web Sockets HTML5 Event Source Streaming over HTTP","title":"Web Architecture 101"},{"location":"concepts/architecture.html#web-architecture-101","text":"","title":"Web Architecture 101"},{"location":"concepts/architecture.html#http-push","text":"Ajax Long polling Web Sockets HTML5 Event Source Streaming over HTTP","title":"HTTP Push"},{"location":"concepts/fallacies.html","text":"Fallacies of Distributed Computing Network is reliable Calls over network can fail for various reasons. Therefore, Do automatic retries with idempotency Implement store and forward pattern with queues Latency is zero Sending data across a network is multiple orders of magnitude slower than making a local method call. Therefore, Avoid chatty network communication by bringing all the data at once Avoid Select N+1 problem by keeping remote calls coarse-grained Move the data closer to client - CDNs & Caching Invert flow of data - use pub/sub model with local storage Bandwidth is infinite Mobile and video streaming apps are sensitive to high bandwidth usage. Therefore, Use Domain driven design Don't strive for single enterprise domain model but rather partition domain model into BoundedContexts Avoid large object graph inside bounded contexts by using Aggregate pattern Use CQRS - Command Query Responsibility Separation Optimize read and write with separate models Network is secure Since security cannot be an afterthought, Do layered defense at different levels - network, application, storage Handle OWASP Top 10 vulnerabilities Implement threat modelling identify assets and access patterns identify possible attacks and execute them Topology doesn\u2019t change Since network topology changes all the time, we need to Abstract physical network Don\u2019t hardcode IPs - use DNS Use service discovery when IP and port are needed Use Service bus or multi cast for location transparency Treat servers as Cattle, Not pets Implement Chaos monkey There is one administrator In a complex system, it is impossible for one person to know everything. Therefore, Implement Centralized logging & monitoring Involve administrators early to spot production constraints (security, firewall, configurations) Decouple systems with queues Implement backward-compatible connections to allow for independent component upgrades Isolate/Abstract 3rd party systems Transport cost is zero Transporting data over network has a price both in time and resources. Serializing and deserializing data for transport involves CPU time and network infrastructure involves atleast a maintenance cost. Therefore, Choose the transport format wisely XML > JSON > ProtoBuf (in the order decreasing cost) Network is homogeneous Having a homogeneous network is impossible to achieve. Therefore, Avoid vendor lock-in with proprietary protocols Choose standard formats for communication - Json, XML, etc References Understanding the 8 Fallacies of Distributed Systems - Dzone Whitepaper - Arnon Rotem-Gal-Oz","title":"Fallacies of Distributed Computing"},{"location":"concepts/fallacies.html#fallacies-of-distributed-computing","text":"","title":"Fallacies of Distributed Computing"},{"location":"concepts/fallacies.html#network-is-reliable","text":"Calls over network can fail for various reasons. Therefore, Do automatic retries with idempotency Implement store and forward pattern with queues","title":"Network is reliable"},{"location":"concepts/fallacies.html#latency-is-zero","text":"Sending data across a network is multiple orders of magnitude slower than making a local method call. Therefore, Avoid chatty network communication by bringing all the data at once Avoid Select N+1 problem by keeping remote calls coarse-grained Move the data closer to client - CDNs & Caching Invert flow of data - use pub/sub model with local storage","title":"Latency is zero"},{"location":"concepts/fallacies.html#bandwidth-is-infinite","text":"Mobile and video streaming apps are sensitive to high bandwidth usage. Therefore, Use Domain driven design Don't strive for single enterprise domain model but rather partition domain model into BoundedContexts Avoid large object graph inside bounded contexts by using Aggregate pattern Use CQRS - Command Query Responsibility Separation Optimize read and write with separate models","title":"Bandwidth is infinite"},{"location":"concepts/fallacies.html#network-is-secure","text":"Since security cannot be an afterthought, Do layered defense at different levels - network, application, storage Handle OWASP Top 10 vulnerabilities Implement threat modelling identify assets and access patterns identify possible attacks and execute them","title":"Network is secure"},{"location":"concepts/fallacies.html#topology-doesnt-change","text":"Since network topology changes all the time, we need to Abstract physical network Don\u2019t hardcode IPs - use DNS Use service discovery when IP and port are needed Use Service bus or multi cast for location transparency Treat servers as Cattle, Not pets Implement Chaos monkey","title":"Topology doesn\u2019t change"},{"location":"concepts/fallacies.html#there-is-one-administrator","text":"In a complex system, it is impossible for one person to know everything. Therefore, Implement Centralized logging & monitoring Involve administrators early to spot production constraints (security, firewall, configurations) Decouple systems with queues Implement backward-compatible connections to allow for independent component upgrades Isolate/Abstract 3rd party systems","title":"There is one administrator"},{"location":"concepts/fallacies.html#transport-cost-is-zero","text":"Transporting data over network has a price both in time and resources. Serializing and deserializing data for transport involves CPU time and network infrastructure involves atleast a maintenance cost. Therefore, Choose the transport format wisely XML > JSON > ProtoBuf (in the order decreasing cost)","title":"Transport cost is zero"},{"location":"concepts/fallacies.html#network-is-homogeneous","text":"Having a homogeneous network is impossible to achieve. Therefore, Avoid vendor lock-in with proprietary protocols Choose standard formats for communication - Json, XML, etc References Understanding the 8 Fallacies of Distributed Systems - Dzone Whitepaper - Arnon Rotem-Gal-Oz","title":"Network is homogeneous"},{"location":"concepts/glossary.html","text":"Tail latencies Head-of-line blocking Polyglot persistence","title":"Glossary"},{"location":"concepts/http2.html","text":"HTTP/2 HTTP1.1 limitations Head of line blocking problem HTTP pipelining allows all requests to be sent at once without waiting for the response. But that didn't solve the problem because servers still needed to respond in order Inefficient use of TCP connections Protocol allows only one outstanding request per TCP connection. Therefore, browsers need multiple TCP connections for parallelism but that causes TCP congestion. Hence, browser place a limit on concurrent download per domain (between 2-16) Fat HTTP headers without any compression Cookie How did applications handle HTTP/1.1 limitations? Head of line blocking was worked around by domain sharding Using CSS sprites that combine multiple images into a single one so that they're loaded in a single HTTP request Inlining JS and CSS Gzipping Multiple CDNs How is HTTP/2 better than HTTP/1.1 HTTP/2 is a single TLS encrypted connection Request/Response are a logical stream. Each streams is chunked into header and data frames and multiplexed on the same connection avoiding head of line blocking Headers are heavily compressed (HPack) to benefit repeated http requests Server push 1. Framing in HTTP/2 2. Stream Multiplexing 3. Header Compression Uses Huffman Coding 4. Server push References HTTP/2 101 - Chrome Dev summit (video) HTTP/2 performance - Google Learning HTTP/2 - Oreilly (book) High Performance Browser Networking - Chapter (book)","title":"HTTP/2"},{"location":"concepts/http2.html#http2","text":"","title":"HTTP/2"},{"location":"concepts/http2.html#http11-limitations","text":"Head of line blocking problem HTTP pipelining allows all requests to be sent at once without waiting for the response. But that didn't solve the problem because servers still needed to respond in order Inefficient use of TCP connections Protocol allows only one outstanding request per TCP connection. Therefore, browsers need multiple TCP connections for parallelism but that causes TCP congestion. Hence, browser place a limit on concurrent download per domain (between 2-16) Fat HTTP headers without any compression Cookie","title":"HTTP1.1 limitations"},{"location":"concepts/http2.html#how-did-applications-handle-http11-limitations","text":"Head of line blocking was worked around by domain sharding Using CSS sprites that combine multiple images into a single one so that they're loaded in a single HTTP request Inlining JS and CSS Gzipping Multiple CDNs","title":"How did applications handle HTTP/1.1 limitations?"},{"location":"concepts/http2.html#how-is-http2-better-than-http11","text":"HTTP/2 is a single TLS encrypted connection Request/Response are a logical stream. Each streams is chunked into header and data frames and multiplexed on the same connection avoiding head of line blocking Headers are heavily compressed (HPack) to benefit repeated http requests Server push","title":"How is HTTP/2 better than HTTP/1.1"},{"location":"concepts/http2.html#1-framing-in-http2","text":"","title":"1. Framing in HTTP/2"},{"location":"concepts/http2.html#2-stream-multiplexing","text":"","title":"2. Stream Multiplexing"},{"location":"concepts/http2.html#3-header-compression","text":"Uses Huffman Coding","title":"3. Header Compression"},{"location":"concepts/http2.html#4-server-push","text":"References HTTP/2 101 - Chrome Dev summit (video) HTTP/2 performance - Google Learning HTTP/2 - Oreilly (book) High Performance Browser Networking - Chapter (book)","title":"4. Server push"},{"location":"concepts/networking101.html","text":"Networking 101 History of Internet (video) Ip Address Exhaustion Solution Class based network Class A - 16 million = 2^24 Class B - 65,536 Class C - 256 Possible solutions: NAT - Having private address CIDR - Classless Inter domain routing Reclaim addresses IPv6 - 128 bit addresses = Speed is a feature Delay User perception 0\u2013100 ms Instant 100\u2013300 ms Small perceptible delay 300\u20131000 ms Machine is working 1,000+ ms Likely mental context switch 10,000+ ms Task is abandoned source Because faster sites mean better user engagement better user retention better conversion Transatlantic cable \" Hibernia Express \" was laid between London and NewYork to give an edge of ~5 milliseconds over other transatlantic cables Latency is caused by Propogation delay = distance/speed of medium(light) Transmission delay = time required to push all data bits into the link Transmitting 10MB data over 100Mbps link would be faster (0.8 sec) than sending it over 1Mbps link (80 sec). 10MB = 80Mb Processing delay = time taken by router to process the packet header, check for bit-level errors and determine packet's destination Queuing delay = time the packet waits in router's incoming buffer before it can be processed Refractive Index = Speed of light / Speed of light in the medium Eg., Refractive index of Optical fiber is \\~1.4. Therefore, maximum speed of light in optical fiber = 200,000,000 m/sec Route Distance Latency RTT NewYork to SanFrancisco ~4000km ~20ms ~40ms NewYork to Amsterdam ~6000km ~30ms ~60ms NewYork to Sydney ~16000km ~80ms ~160ms Earth's Circumference ~40000km ~200ms ~200ms TCP TCP provides an effective abstraction of a reliable network running over an unreliable channel. It hides most of the complexity of network communication from our applications: * retransmission of lost data * in-order delivery * congestion control and avoidance * data integrity * and more TCP is optimized for accurate delivery, rather than a timely one. Three-way Handshake Thus, each new connection will have a full roundtrip of latency before any application data can be transferred. Congestion Avoidance and Control Design Philosophy of DARPA Internet Protocols source Fundamental Goal Effective technique for multiplexed utilization of existing interconnected networks (ARPANET, PRNET) Sharing/multiplexing was solved with Packed switching Interconnection was solved with narrow waist Udacity course Secondary goals Survivability in the face of failure: Replication Fate-sharing - acceptable to lose state information of an entity if the entity itself is lost. Eg., Routing tables lost when a router crashes Heterogenity achieved through TCP/IP TCP provided flow control and reliability though some usecases didn't need it. Eg., streaming (voice/video), DNS resolution TCP works on best effort which makes debugging hard Distributed Management Addressing (ARIN, RIPE, etc) Naming (DNS) Routing (BGP) End-to-End Argument source Summary: Dumb network and intelligent endpoints Eg., Violation NAT which maintains a map of device ip and port on private network to the static public ip and port Switching & Bridging Host hosts find each other on the network Each Network Adapter has a MAC address and a computer can send a Ethernet datagram to another computer if it knows the recipient's MAC address. But in reality only DNS name or IP of the destination machine is known. ARP protocol Broadcast asking for IP. Receive a unicast with MAC address Build a table of IP to MAC address Hub : Broadcast Switch: Do traffic isolation Learning Switch Floods the network when there is no mapping. Otherwise, send to the correct port. Loop and Broadcast Storms Routing Types: * Intradomain * Interdomain Different Autonomous Systems (AS): * ISPs * Service providers (Google, etc) * Standalone institutions (Universities) Node = PoPs (Points of Presence) usually located in densely populated centers Edges have fiber paths which are closer to major transportational routes Intradomain routing Distance-Vector routing Uses Bellmann-Ford algorithm References :","title":"Networking 101"},{"location":"concepts/networking101.html#networking-101","text":"History of Internet (video)","title":"Networking 101"},{"location":"concepts/networking101.html#ip-address-exhaustion-solution","text":"Class based network Class A - 16 million = 2^24 Class B - 65,536 Class C - 256 Possible solutions: NAT - Having private address CIDR - Classless Inter domain routing Reclaim addresses IPv6 - 128 bit addresses =","title":"Ip Address Exhaustion Solution"},{"location":"concepts/networking101.html#speed-is-a-feature","text":"Delay User perception 0\u2013100 ms Instant 100\u2013300 ms Small perceptible delay 300\u20131000 ms Machine is working 1,000+ ms Likely mental context switch 10,000+ ms Task is abandoned source Because faster sites mean better user engagement better user retention better conversion Transatlantic cable \" Hibernia Express \" was laid between London and NewYork to give an edge of ~5 milliseconds over other transatlantic cables Latency is caused by Propogation delay = distance/speed of medium(light) Transmission delay = time required to push all data bits into the link Transmitting 10MB data over 100Mbps link would be faster (0.8 sec) than sending it over 1Mbps link (80 sec). 10MB = 80Mb Processing delay = time taken by router to process the packet header, check for bit-level errors and determine packet's destination Queuing delay = time the packet waits in router's incoming buffer before it can be processed Refractive Index = Speed of light / Speed of light in the medium Eg., Refractive index of Optical fiber is \\~1.4. Therefore, maximum speed of light in optical fiber = 200,000,000 m/sec Route Distance Latency RTT NewYork to SanFrancisco ~4000km ~20ms ~40ms NewYork to Amsterdam ~6000km ~30ms ~60ms NewYork to Sydney ~16000km ~80ms ~160ms Earth's Circumference ~40000km ~200ms ~200ms","title":"Speed is a feature"},{"location":"concepts/networking101.html#tcp","text":"TCP provides an effective abstraction of a reliable network running over an unreliable channel. It hides most of the complexity of network communication from our applications: * retransmission of lost data * in-order delivery * congestion control and avoidance * data integrity * and more TCP is optimized for accurate delivery, rather than a timely one.","title":"TCP"},{"location":"concepts/networking101.html#three-way-handshake","text":"Thus, each new connection will have a full roundtrip of latency before any application data can be transferred.","title":"Three-way Handshake"},{"location":"concepts/networking101.html#congestion-avoidance-and-control","text":"","title":"Congestion Avoidance and Control"},{"location":"concepts/networking101.html#design-philosophy-of-darpa-internet-protocols","text":"source","title":"Design Philosophy of DARPA Internet Protocols"},{"location":"concepts/networking101.html#fundamental-goal","text":"Effective technique for multiplexed utilization of existing interconnected networks (ARPANET, PRNET) Sharing/multiplexing was solved with Packed switching Interconnection was solved with narrow waist Udacity course","title":"Fundamental Goal"},{"location":"concepts/networking101.html#secondary-goals","text":"Survivability in the face of failure: Replication Fate-sharing - acceptable to lose state information of an entity if the entity itself is lost. Eg., Routing tables lost when a router crashes Heterogenity achieved through TCP/IP TCP provided flow control and reliability though some usecases didn't need it. Eg., streaming (voice/video), DNS resolution TCP works on best effort which makes debugging hard Distributed Management Addressing (ARIN, RIPE, etc) Naming (DNS) Routing (BGP)","title":"Secondary goals"},{"location":"concepts/networking101.html#end-to-end-argument","text":"source Summary: Dumb network and intelligent endpoints Eg., Violation NAT which maintains a map of device ip and port on private network to the static public ip and port","title":"End-to-End Argument"},{"location":"concepts/networking101.html#switching-bridging","text":"","title":"Switching &amp; Bridging"},{"location":"concepts/networking101.html#host-hosts-find-each-other-on-the-network","text":"Each Network Adapter has a MAC address and a computer can send a Ethernet datagram to another computer if it knows the recipient's MAC address. But in reality only DNS name or IP of the destination machine is known. ARP protocol Broadcast asking for IP. Receive a unicast with MAC address Build a table of IP to MAC address Hub : Broadcast Switch: Do traffic isolation Learning Switch Floods the network when there is no mapping. Otherwise, send to the correct port. Loop and Broadcast Storms","title":"Host hosts find each other on the network"},{"location":"concepts/networking101.html#routing","text":"Types: * Intradomain * Interdomain Different Autonomous Systems (AS): * ISPs * Service providers (Google, etc) * Standalone institutions (Universities) Node = PoPs (Points of Presence) usually located in densely populated centers Edges have fiber paths which are closer to major transportational routes","title":"Routing"},{"location":"concepts/networking101.html#intradomain-routing","text":"","title":"Intradomain routing"},{"location":"concepts/networking101.html#distance-vector-routing","text":"Uses Bellmann-Ford algorithm References :","title":"Distance-Vector routing"},{"location":"concepts/numbers.html","text":"Numbers every programmer should know Latency Numbers (~2020) Event nano sec micro sec mill sec Notes L1 Cache reference 1 L2 Cache reference 4 4xL1 Main memory/RAM reference 100 25xL2, 100xL1 Read 1MB sequentially from main memory 3,000 3 Read 1MB sequentially from SSD 49,000 49 16xmemory Read 1MB sequentially from disk 825,000 825 16xSSD,275xmemory Round trip network request in same data centre 500000 500 Disk (Hard drive / magnetic drive) seek 2,000,000 2,000 2 4xdata center round trip Packet roundtrip from CA to Netherlands 150,000,000 150,000 150 Branch mispredict 3 Mutex Lock/Unlock 17 Send 2000 bytes over commodity network 44 Compress 1 KB with Zippy 2,000 2 Solid State Drive (SSD) random read 16,000 16 References Interactive timeline Updated numbers - Medium","title":"Numbers everyone should know"},{"location":"concepts/numbers.html#numbers-every-programmer-should-know","text":"","title":"Numbers every programmer should know"},{"location":"concepts/numbers.html#latency-numbers-2020","text":"Event nano sec micro sec mill sec Notes L1 Cache reference 1 L2 Cache reference 4 4xL1 Main memory/RAM reference 100 25xL2, 100xL1 Read 1MB sequentially from main memory 3,000 3 Read 1MB sequentially from SSD 49,000 49 16xmemory Read 1MB sequentially from disk 825,000 825 16xSSD,275xmemory Round trip network request in same data centre 500000 500 Disk (Hard drive / magnetic drive) seek 2,000,000 2,000 2 4xdata center round trip Packet roundtrip from CA to Netherlands 150,000,000 150,000 150 Branch mispredict 3 Mutex Lock/Unlock 17 Send 2000 bytes over commodity network 44 Compress 1 KB with Zippy 2,000 2 Solid State Drive (SSD) random read 16,000 16 References Interactive timeline Updated numbers - Medium","title":"Latency Numbers (~2020)"},{"location":"concepts/web-perf.html","text":"Website Performance Best practices of Web performance Optimize DNS Lookups Limit the number of unique domain names Ensure low DNS resolution latencies Leverage DNS pre-fetch Optimie TCP connections Leverage Preconnect which sets up early connections before an HTTP request is actually sent to the server Use a CDN closer to user. This indirectly reduces the RTT for the TCP connection Implement latest TLS best practices Avoid Redirects - that usually causes connection to new hostnames Cache on client - TTL Cache images forever CSS/JS - cache for twice the median session time so it is relatively fresh Use conditional caching Using ETag that uniquely identifies the object so server can return HTTP 304 if it is requested again Using If-modified-since in http request so server can return HTTP 304 Compression and Minification All text content (Html,JS,CSS,Json) benefit from compresison - gzip, deflate Avoid Blocking CSS/JS Add all the CSS elements in the head section Use 'async' attribute for JS than be downloaded parallely while HTML is being parsed but before the DOM is loaded Use 'defer' attribute for JS that can be run after DOM is loaded Optimize Images Remove metadata like location, timestamp, image dimension, resolution Scaling images for different viewport Anitpatterns with HTTP/2 Domain Sharding as that creates multiple TCP connections CSS Spriting Concatenation of files Inlining References High Performance Browser Networking - Oreilly (book) High Performance websites - Oreilly (book) Building Fast & Resilient Web Applications - Ilya Grigorik (video)","title":"Website Performance"},{"location":"concepts/web-perf.html#website-performance","text":"","title":"Website Performance"},{"location":"concepts/web-perf.html#best-practices-of-web-performance","text":"Optimize DNS Lookups Limit the number of unique domain names Ensure low DNS resolution latencies Leverage DNS pre-fetch Optimie TCP connections Leverage Preconnect which sets up early connections before an HTTP request is actually sent to the server Use a CDN closer to user. This indirectly reduces the RTT for the TCP connection Implement latest TLS best practices Avoid Redirects - that usually causes connection to new hostnames Cache on client - TTL Cache images forever CSS/JS - cache for twice the median session time so it is relatively fresh Use conditional caching Using ETag that uniquely identifies the object so server can return HTTP 304 if it is requested again Using If-modified-since in http request so server can return HTTP 304 Compression and Minification All text content (Html,JS,CSS,Json) benefit from compresison - gzip, deflate Avoid Blocking CSS/JS Add all the CSS elements in the head section Use 'async' attribute for JS than be downloaded parallely while HTML is being parsed but before the DOM is loaded Use 'defer' attribute for JS that can be run after DOM is loaded Optimize Images Remove metadata like location, timestamp, image dimension, resolution Scaling images for different viewport","title":"Best practices of Web performance"},{"location":"concepts/web-perf.html#anitpatterns-with-http2","text":"Domain Sharding as that creates multiple TCP connections CSS Spriting Concatenation of files Inlining References High Performance Browser Networking - Oreilly (book) High Performance websites - Oreilly (book) Building Fast & Resilient Web Applications - Ilya Grigorik (video)","title":"Anitpatterns with HTTP/2"},{"location":"concepts/webapp101.html","text":"WebApp 101 Difference between n-tier and n-layer Tier - physical separation at the component level and not at the code level 5 different HTTP push mechanisms Ajax long polling Web Sockets bi-directional chat, browser games, social streams HTML5 Event Source API (frontend) & Server sent events (backend) uni-directional realtime feeds - twitter, etc HTML5 Streaming API chunked video streaming Message queues What is Scalability Ability to handle increased workload without sacrificing latency Scalability Bottlenecks Scaling DB Absence of Asynchronocity Not using Caching (wisely) Incorrect setup of Load balancers Code-level issues What is HA High availability (HA) is the ability of the system to stay online despite having failures at the infrastructural level in real-time. Reasons: Hardware Software Human errors How to achieve HA Redundancy - Active Passive HA mode Redundancy is duplicating the components or instances & keeping them on standby to take over in case the active instances go down. It\u2019s the fail-safe, backup mechanism. Replication - Active Active HA mode Replication means having a number of similar nodes running the workload together. There are no standby or passive instances. Types of Load balancing DNS load balancing DNS load balancing enables the authoritative server to return different IP addresses of a certain domain to the clients. Every time it receives a query for an IP, it returns a list of IP addresses of a domain to the client. Hardware Software HAproxy Different load balancing algorithms (Weighted) Round-robin Least connections Random Hash Types of Databases Document-oriented Product catalogue News feed Web based games Graph Key value Wide column Time series Relational Caching Strategies Cache aside Data loaded lazily Suitable for read-heavy loads Read through Similar to cache-aside but cache is always consistent with database Write through Write to cache before DB Small latency overhead Write back Data only written to cache After a delay, it is written to db in bulk TODO HTML5 Event Source API (frontend) & Server sent events (backend) HTML5 Streaming API HA Clustering","title":"WebApp 101"},{"location":"concepts/webapp101.html#webapp-101","text":"","title":"WebApp 101"},{"location":"concepts/webapp101.html#difference-between-n-tier-and-n-layer","text":"Tier - physical separation at the component level and not at the code level","title":"Difference between n-tier and n-layer"},{"location":"concepts/webapp101.html#5-different-http-push-mechanisms","text":"Ajax long polling Web Sockets bi-directional chat, browser games, social streams HTML5 Event Source API (frontend) & Server sent events (backend) uni-directional realtime feeds - twitter, etc HTML5 Streaming API chunked video streaming Message queues","title":"5 different HTTP push mechanisms"},{"location":"concepts/webapp101.html#what-is-scalability","text":"Ability to handle increased workload without sacrificing latency","title":"What is Scalability"},{"location":"concepts/webapp101.html#scalability-bottlenecks","text":"Scaling DB Absence of Asynchronocity Not using Caching (wisely) Incorrect setup of Load balancers Code-level issues","title":"Scalability Bottlenecks"},{"location":"concepts/webapp101.html#what-is-ha","text":"High availability (HA) is the ability of the system to stay online despite having failures at the infrastructural level in real-time. Reasons: Hardware Software Human errors","title":"What is HA"},{"location":"concepts/webapp101.html#how-to-achieve-ha","text":"Redundancy - Active Passive HA mode Redundancy is duplicating the components or instances & keeping them on standby to take over in case the active instances go down. It\u2019s the fail-safe, backup mechanism. Replication - Active Active HA mode Replication means having a number of similar nodes running the workload together. There are no standby or passive instances.","title":"How to achieve HA"},{"location":"concepts/webapp101.html#types-of-load-balancing","text":"DNS load balancing DNS load balancing enables the authoritative server to return different IP addresses of a certain domain to the clients. Every time it receives a query for an IP, it returns a list of IP addresses of a domain to the client. Hardware Software HAproxy","title":"Types of Load balancing"},{"location":"concepts/webapp101.html#different-load-balancing-algorithms","text":"(Weighted) Round-robin Least connections Random Hash","title":"Different load balancing algorithms"},{"location":"concepts/webapp101.html#types-of-databases","text":"Document-oriented Product catalogue News feed Web based games Graph Key value Wide column Time series Relational","title":"Types of Databases"},{"location":"concepts/webapp101.html#caching-strategies","text":"Cache aside Data loaded lazily Suitable for read-heavy loads Read through Similar to cache-aside but cache is always consistent with database Write through Write to cache before DB Small latency overhead Write back Data only written to cache After a delay, it is written to db in bulk","title":"Caching Strategies"},{"location":"concepts/webapp101.html#todo","text":"HTML5 Event Source API (frontend) & Server sent events (backend) HTML5 Streaming API HA Clustering","title":"TODO"},{"location":"sdi/numbers.html","text":"Useful numbers for System Design Interviews: Demographic Description Quantity Comparison World population in 2019 7.7 billion Internet users 4.5 billion 60% Social media users 3.8 billion 50% Smartphone users 3.5 billion 45% No. of software developers 23 million 0.003% Mobile usage Description Quantity No. of mobile connections 9.5 billion No. of unique mobile connections 5.2 billion Time on phone by avg. user 90min/day Monthly Active Users Application No of active users Facebook 2.4 billion Youtube 2 billion Whatsapp 1.6 billion Wechat 1 billion Instagram 1 billion Tiktok 800 million Reddit 300 million Twitter 300 million Basic numbers Description Quantity No of seconds in a day 86400 No of seconds in a year 31 million \\~1million req/day = \\~11.5req/sec Average Web page size is 2MB with an average of 100 objects Blink of an eye = 300-400 milli secs. Google study says that much delay causes people to search less Size of a data packet = 1.5Kb IpV4 address - 32 bits = \\~4 billion addresses References Statistics World population Mobile Phone statistics Internet statistics Social network statistics Social media statistics HTTP usage statistics","title":"Useful numbers"},{"location":"sdi/numbers.html#useful-numbers-for-system-design-interviews","text":"","title":"Useful numbers for System Design Interviews:"},{"location":"sdi/numbers.html#demographic","text":"Description Quantity Comparison World population in 2019 7.7 billion Internet users 4.5 billion 60% Social media users 3.8 billion 50% Smartphone users 3.5 billion 45% No. of software developers 23 million 0.003%","title":"Demographic"},{"location":"sdi/numbers.html#mobile-usage","text":"Description Quantity No. of mobile connections 9.5 billion No. of unique mobile connections 5.2 billion Time on phone by avg. user 90min/day","title":"Mobile usage"},{"location":"sdi/numbers.html#monthly-active-users","text":"Application No of active users Facebook 2.4 billion Youtube 2 billion Whatsapp 1.6 billion Wechat 1 billion Instagram 1 billion Tiktok 800 million Reddit 300 million Twitter 300 million","title":"Monthly Active Users"},{"location":"sdi/numbers.html#basic-numbers","text":"Description Quantity No of seconds in a day 86400 No of seconds in a year 31 million \\~1million req/day = \\~11.5req/sec Average Web page size is 2MB with an average of 100 objects Blink of an eye = 300-400 milli secs. Google study says that much delay causes people to search less Size of a data packet = 1.5Kb IpV4 address - 32 bits = \\~4 billion addresses References Statistics World population Mobile Phone statistics Internet statistics Social network statistics Social media statistics HTTP usage statistics","title":"Basic numbers"}]}