{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome here! I'm not an expert in systems design but I've lately started reading more about designing distributed systems. And this site is an attempt to document my notes both for sharing and future reference. As I begin this journey, though I have a list of topics to cover, I don't have a concrete structure in my mind to organize these notes. But I hope over time I should be able to find a structure and reorganize them. TODO: https://www.enterpriseintegrationpatterns.com/patterns/messaging/Introduction.html","title":"Welcome here!"},{"location":"index.html#welcome-here","text":"I'm not an expert in systems design but I've lately started reading more about designing distributed systems. And this site is an attempt to document my notes both for sharing and future reference. As I begin this journey, though I have a list of topics to cover, I don't have a concrete structure in my mind to organize these notes. But I hope over time I should be able to find a structure and reorganize them.","title":"Welcome here!"},{"location":"index.html#todo","text":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/Introduction.html","title":"TODO:"},{"location":"books/ddia.html","text":"Designing data-intensive applications Standard Building blocks Databases to store data Caches to speed-up reads or remember expensive operation Queues/Streams for asynchronous processing Indexes for searching and filtering stored data Offline processing for crunching accumulated data or async operations","title":"Designing data intensive applications"},{"location":"books/ddia.html#designing-data-intensive-applications","text":"","title":"Designing data-intensive applications"},{"location":"books/ddia.html#standard-building-blocks","text":"Databases to store data Caches to speed-up reads or remember expensive operation Queues/Streams for asynchronous processing Indexes for searching and filtering stored data Offline processing for crunching accumulated data or async operations","title":"Standard Building blocks"},{"location":"concepts/architecture.html","text":"Web Architecture 101 HTTP Push","title":"Web Architecture 101"},{"location":"concepts/architecture.html#web-architecture-101","text":"","title":"Web Architecture 101"},{"location":"concepts/architecture.html#http-push","text":"","title":"HTTP Push"},{"location":"concepts/fallacies.html","text":"Fallacies of Distributed Computing Network is reliable Calls over network can fail for various reasons. Therefore, Do automatic retries with idempotency Implement store and forward pattern with queues Latency is zero Sending data across a network is multiple orders of magnitude slower than making a local method call. Therefore, Avoid chatty network communication by bringing all the data at once Avoid Select N+1 problem by keeping remote calls coarse-grained Move the data closer to client - CDNs & Caching Invert flow of data - use pub/sub model with local storage Bandwidth is infinite Mobile and video streaming apps are sensitive to high bandwidth usage. Therefore, Use Domain driven design Don't strive for single enterprise domain model but rather partition domain model into BoundedContexts Avoid large object graph inside bounded contexts by using Aggregate pattern Use CQRS - Command Query Responsibility Separation Optimize read and write with separate models Network is secure Since security cannot be an afterthought, Do layered defense at different levels - network, application, storage Handle OWASP Top 10 vulnerabilities Implement threat modelling identify assets and access patterns identify possible attacks and execute them Topology doesn\u2019t change Since network topology changes all the time, we need to Abstract physical network Don\u2019t hardcode IPs - use DNS Use service discovery when IP and port are needed Use Service bus or multi cast for location transparency Treat servers as Cattle, Not pets Implement Chaos monkey There is one administrator In a complex system, it is impossible for one person to know everything. Therefore, Implement Centralized logging & monitoring Involve administrators early to spot production constraints (security, firewall, configurations) Decouple systems with queues Implement backward-compatible connections to allow for independent component upgrades Isolate/Abstract 3rd party systems Transport cost is zero Transporting data over network has a price both in time and resources. Serializing and deserializing data for transport involves CPU time and network infrastructure involves atleast a maintenance cost. Therefore, Choose the transport format wisely XML > JSON > ProtoBuf (in the order decreasing cost) Network is homogeneous Having a homogeneous network is impossible to achieve. Therefore, Avoid vendor lock-in with proprietary protocols Choose standard formats for communication - Json, XML, etc References Understanding the 8 Fallacies of Distributed Systems - Dzone Whitepaper - Arnon Rotem-Gal-Oz","title":"Fallacies of Distributed Computing"},{"location":"concepts/fallacies.html#fallacies-of-distributed-computing","text":"","title":"Fallacies of Distributed Computing"},{"location":"concepts/fallacies.html#network-is-reliable","text":"Calls over network can fail for various reasons. Therefore, Do automatic retries with idempotency Implement store and forward pattern with queues","title":"Network is reliable"},{"location":"concepts/fallacies.html#latency-is-zero","text":"Sending data across a network is multiple orders of magnitude slower than making a local method call. Therefore, Avoid chatty network communication by bringing all the data at once Avoid Select N+1 problem by keeping remote calls coarse-grained Move the data closer to client - CDNs & Caching Invert flow of data - use pub/sub model with local storage","title":"Latency is zero"},{"location":"concepts/fallacies.html#bandwidth-is-infinite","text":"Mobile and video streaming apps are sensitive to high bandwidth usage. Therefore, Use Domain driven design Don't strive for single enterprise domain model but rather partition domain model into BoundedContexts Avoid large object graph inside bounded contexts by using Aggregate pattern Use CQRS - Command Query Responsibility Separation Optimize read and write with separate models","title":"Bandwidth is infinite"},{"location":"concepts/fallacies.html#network-is-secure","text":"Since security cannot be an afterthought, Do layered defense at different levels - network, application, storage Handle OWASP Top 10 vulnerabilities Implement threat modelling identify assets and access patterns identify possible attacks and execute them","title":"Network is secure"},{"location":"concepts/fallacies.html#topology-doesnt-change","text":"Since network topology changes all the time, we need to Abstract physical network Don\u2019t hardcode IPs - use DNS Use service discovery when IP and port are needed Use Service bus or multi cast for location transparency Treat servers as Cattle, Not pets Implement Chaos monkey","title":"Topology doesn\u2019t change"},{"location":"concepts/fallacies.html#there-is-one-administrator","text":"In a complex system, it is impossible for one person to know everything. Therefore, Implement Centralized logging & monitoring Involve administrators early to spot production constraints (security, firewall, configurations) Decouple systems with queues Implement backward-compatible connections to allow for independent component upgrades Isolate/Abstract 3rd party systems","title":"There is one administrator"},{"location":"concepts/fallacies.html#transport-cost-is-zero","text":"Transporting data over network has a price both in time and resources. Serializing and deserializing data for transport involves CPU time and network infrastructure involves atleast a maintenance cost. Therefore, Choose the transport format wisely XML > JSON > ProtoBuf (in the order decreasing cost)","title":"Transport cost is zero"},{"location":"concepts/fallacies.html#network-is-homogeneous","text":"Having a homogeneous network is impossible to achieve. Therefore, Avoid vendor lock-in with proprietary protocols Choose standard formats for communication - Json, XML, etc References Understanding the 8 Fallacies of Distributed Systems - Dzone Whitepaper - Arnon Rotem-Gal-Oz","title":"Network is homogeneous"},{"location":"concepts/http2.html","text":"HTTP/2 HTTP1.1 limitations Head of line blocking problem HTTP pipelining allows all requests to be sent at once without waiting for the response. But that didn't solve the problem because servers still needed to respond in order Inefficient use of TCP connections Protocol allows only one outstanding request per TCP connection. Therefore, browsers need multiple TCP connections for parallelism but that causes TCP congestion. Hence, browser place a limit on concurrent download per domain (between 2-16) Fat HTTP headers without any compression Cookie How did applications handle HTTP/1.1 limitations? Head of line blocking was worked around by domain sharding Using CSS sprites that combine multiple images into a single one so that they're loaded in a single HTTP request Inlining JS and CSS Gzipping Multiple CDNs How is HTTP/2 better than HTTP/1.1 HTTP/2 is a single TLS encrypted connection Request/Response are a logical stream. Each streams is chunked into header and data frames and multiplexed on the same connection avoiding head of line blocking Headers are heavily compressed (HPack) to benefit repeated http requests Server push 1. Framing in HTTP/2 2. Stream Multiplexing 3. Header Compression Uses Huffman Coding 4. Server push References HTTP/2 101 - Chrome Dev summit (video) HTTP/2 performance - Google Learning HTTP/2 - Oreilly (book)","title":"HTTP/2"},{"location":"concepts/http2.html#http2","text":"","title":"HTTP/2"},{"location":"concepts/http2.html#http11-limitations","text":"Head of line blocking problem HTTP pipelining allows all requests to be sent at once without waiting for the response. But that didn't solve the problem because servers still needed to respond in order Inefficient use of TCP connections Protocol allows only one outstanding request per TCP connection. Therefore, browsers need multiple TCP connections for parallelism but that causes TCP congestion. Hence, browser place a limit on concurrent download per domain (between 2-16) Fat HTTP headers without any compression Cookie","title":"HTTP1.1 limitations"},{"location":"concepts/http2.html#how-did-applications-handle-http11-limitations","text":"Head of line blocking was worked around by domain sharding Using CSS sprites that combine multiple images into a single one so that they're loaded in a single HTTP request Inlining JS and CSS Gzipping Multiple CDNs","title":"How did applications handle HTTP/1.1 limitations?"},{"location":"concepts/http2.html#how-is-http2-better-than-http11","text":"HTTP/2 is a single TLS encrypted connection Request/Response are a logical stream. Each streams is chunked into header and data frames and multiplexed on the same connection avoiding head of line blocking Headers are heavily compressed (HPack) to benefit repeated http requests Server push","title":"How is HTTP/2 better than HTTP/1.1"},{"location":"concepts/http2.html#1-framing-in-http2","text":"","title":"1. Framing in HTTP/2"},{"location":"concepts/http2.html#2-stream-multiplexing","text":"","title":"2. Stream Multiplexing"},{"location":"concepts/http2.html#3-header-compression","text":"Uses Huffman Coding","title":"3. Header Compression"},{"location":"concepts/http2.html#4-server-push","text":"References HTTP/2 101 - Chrome Dev summit (video) HTTP/2 performance - Google Learning HTTP/2 - Oreilly (book)","title":"4. Server push"},{"location":"concepts/numbers.html","text":"Numbers every programmer should know Latency Numbers (~2020) Event nano sec micro sec mill sec Notes L1 Cache reference 1 Branch mispredict 3 L2 Cache reference 4 4xL1 Main memory/RAM reference 100 25xL2, 100xL1 Mutex Lock/Unlock 17 Send 2000 bytes over commodity network 44 Compress 1 KB with Zippy 2,000 2 Read 1MB sequentially from main memory 3,000 3 Read 1MB sequentially from SSD 49,000 49 16xmemory Read 1MB sequentially from disk 825,000 825 16xSSD,275xmemory Solid State Drive (SSD) random read 16,000 16 Round trip network request in same data centre 500000 500 Disk (Hard drive / magnetic drive) seek 2,000,000 2,000 2 4xdata center round trip Packet roundtrip from CA to Netherlands 150,000,000 150,000 150 References Interactive timeline Updated numbers - Medium","title":"Numbers everyone should know"},{"location":"concepts/numbers.html#numbers-every-programmer-should-know","text":"","title":"Numbers every programmer should know"},{"location":"concepts/numbers.html#latency-numbers-2020","text":"Event nano sec micro sec mill sec Notes L1 Cache reference 1 Branch mispredict 3 L2 Cache reference 4 4xL1 Main memory/RAM reference 100 25xL2, 100xL1 Mutex Lock/Unlock 17 Send 2000 bytes over commodity network 44 Compress 1 KB with Zippy 2,000 2 Read 1MB sequentially from main memory 3,000 3 Read 1MB sequentially from SSD 49,000 49 16xmemory Read 1MB sequentially from disk 825,000 825 16xSSD,275xmemory Solid State Drive (SSD) random read 16,000 16 Round trip network request in same data centre 500000 500 Disk (Hard drive / magnetic drive) seek 2,000,000 2,000 2 4xdata center round trip Packet roundtrip from CA to Netherlands 150,000,000 150,000 150 References Interactive timeline Updated numbers - Medium","title":"Latency Numbers (~2020)"},{"location":"concepts/web-perf.html","text":"Website Performance Best practices of Web performance Optimize DNS Lookups Limit the number of unique domain names Ensure low DNS resolution latencies Leverage DNS pre-fetch Optimie TCP connections Leverage Preconnect which sets up early connections before an HTTP request is actually sent to the server Use a CDN closer to user. This indirectly reduces the RTT for the TCP connection Implement latest TLS best practices Avoid Redirects - that usually causes connection to new hostnames Cache on client - TTL Cache images forever CSS/JS - cache for twice the median session time so it is relatively fresh Use conditional caching Using ETag that uniquely identifies the object so server can return HTTP 304 if it is requested again Using If-modified-since in http request so server can return HTTP 304 Compression and Minification All text content (Html,JS,CSS,Json) benefit from compresison - gzip, deflate Avoid Blocking CSS/JS Add all the CSS elements in the head section Use 'async' attribute for JS than be downloaded parallely while HTML is being parsed but before the DOM is loaded Use 'defer' attribute for JS that can be run after DOM is loaded Optimize Images Remove metadata like location, timestamp, image dimension, resolution Scaling images for different viewport Anitpatterns with HTTP/2 Domain Sharding as that creates multiple TCP connections CSS Spriting Concatenation of files Inlining References High Performance Browser Networking - Oreilly (book) High Performance websites - Oreilly (book)","title":"Website Performance"},{"location":"concepts/web-perf.html#website-performance","text":"","title":"Website Performance"},{"location":"concepts/web-perf.html#best-practices-of-web-performance","text":"Optimize DNS Lookups Limit the number of unique domain names Ensure low DNS resolution latencies Leverage DNS pre-fetch Optimie TCP connections Leverage Preconnect which sets up early connections before an HTTP request is actually sent to the server Use a CDN closer to user. This indirectly reduces the RTT for the TCP connection Implement latest TLS best practices Avoid Redirects - that usually causes connection to new hostnames Cache on client - TTL Cache images forever CSS/JS - cache for twice the median session time so it is relatively fresh Use conditional caching Using ETag that uniquely identifies the object so server can return HTTP 304 if it is requested again Using If-modified-since in http request so server can return HTTP 304 Compression and Minification All text content (Html,JS,CSS,Json) benefit from compresison - gzip, deflate Avoid Blocking CSS/JS Add all the CSS elements in the head section Use 'async' attribute for JS than be downloaded parallely while HTML is being parsed but before the DOM is loaded Use 'defer' attribute for JS that can be run after DOM is loaded Optimize Images Remove metadata like location, timestamp, image dimension, resolution Scaling images for different viewport","title":"Best practices of Web performance"},{"location":"concepts/web-perf.html#anitpatterns-with-http2","text":"Domain Sharding as that creates multiple TCP connections CSS Spriting Concatenation of files Inlining References High Performance Browser Networking - Oreilly (book) High Performance websites - Oreilly (book)","title":"Anitpatterns with HTTP/2"},{"location":"sdi/numbers.html","text":"Useful numbers for System Design Interviews: Demographic Description Quantity Comparison World population in 2019 7.7 billion Internet users 4.5 billion 60% Social media users 3.8 billion 50% Smartphone users 3.5 billion 45% No. of software developers 23 million 0.003% Mobile usage Description Quantity No. of mobile connections 9.5 billion No. of unique mobile connections 5.2 billion Time on phone by avg. user 90min/day Monthly Active Users Application No of active users Facebook 2.4 billion Youtube 2 billion Whatsapp 1.6 billion Wechat 1 billion Instagram 1 billion Tiktok 800 million Reddit 300 million Twitter 300 million Basic numbers Description Quantity No of seconds in a day 86400 No of seconds in a year 31 million \\~1million req/day = \\~11.5req/sec Average Web page size is 2MB with an average of 100 objects Blink of an eye = 300-400 milli secs. Google study says that much delay causes people to search less Size of a data packet = 14bytes References Statistics World population Mobile Phone statistics Internet statistics Social network statistics Social media statistics HTTP usage statistics","title":"Useful numbers"},{"location":"sdi/numbers.html#useful-numbers-for-system-design-interviews","text":"","title":"Useful numbers for System Design Interviews:"},{"location":"sdi/numbers.html#demographic","text":"Description Quantity Comparison World population in 2019 7.7 billion Internet users 4.5 billion 60% Social media users 3.8 billion 50% Smartphone users 3.5 billion 45% No. of software developers 23 million 0.003%","title":"Demographic"},{"location":"sdi/numbers.html#mobile-usage","text":"Description Quantity No. of mobile connections 9.5 billion No. of unique mobile connections 5.2 billion Time on phone by avg. user 90min/day","title":"Mobile usage"},{"location":"sdi/numbers.html#monthly-active-users","text":"Application No of active users Facebook 2.4 billion Youtube 2 billion Whatsapp 1.6 billion Wechat 1 billion Instagram 1 billion Tiktok 800 million Reddit 300 million Twitter 300 million","title":"Monthly Active Users"},{"location":"sdi/numbers.html#basic-numbers","text":"Description Quantity No of seconds in a day 86400 No of seconds in a year 31 million \\~1million req/day = \\~11.5req/sec Average Web page size is 2MB with an average of 100 objects Blink of an eye = 300-400 milli secs. Google study says that much delay causes people to search less Size of a data packet = 14bytes References Statistics World population Mobile Phone statistics Internet statistics Social network statistics Social media statistics HTTP usage statistics","title":"Basic numbers"}]}